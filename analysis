!sudo rm -r sample_data/

import os
import h5py
import numpy as np


# Change this directory where you have kept your .h5 file

filename = "19_23k_labels.v001.000_Cropped_19_23k.analysis.h5"

if not os.path.exists(filename):
    print(f"File not found: {filename}")
else:
    with h5py.File(filename, "r") as f:
        dset_names = list(f.keys())
        locations = f["tracks"][:].T
        node_names = [n.decode() for n in f["node_names"][:]]

    print("===filename===")
    print(filename)
    print()

    print("===HDF5 datasets===")
    print(dset_names)
    print()

    print("===locations data shape===")
    print(locations.shape)
    print()

    print("===nodes===")
    for i, name in enumerate(node_names):
        print(f"{i}: {name}")
    print()




frame_count, node_count, _, instance_count = locations.shape

print("frame count:", frame_count)
print("node count:", node_count)
print("instance count:", instance_count)

# Fill missing Values


from scipy.interpolate import interp1d

def fill_missing(Y, kind="linear"):
    """Fills missing values independently along each dimension after the first."""

    # Store initial shape.
    initial_shape = Y.shape

    # Flatten after first dim.
    Y = Y.reshape((initial_shape[0], -1))

    # Interpolate along each slice.
    for i in range(Y.shape[-1]):
        y = Y[:, i]

        # Build interpolant.
        x = np.flatnonzero(~np.isnan(y))
        f = interp1d(x, y[x], kind=kind, fill_value=np.nan, bounds_error=False)

        # Fill missing
        xq = np.flatnonzero(np.isnan(y))
        y[xq] = f(xq)

        # Fill leading or trailing NaNs with the nearest non-NaN values
        mask = np.isnan(y)
        y[mask] = np.interp(np.flatnonzero(mask), np.flatnonzero(~mask), y[~mask])

        # Save slice
        Y[:, i] = y

    # Restore to initial shape.
    Y = Y.reshape(initial_shape)

    return Y

HEAD_INDEX = 0
THORAX_INDEX = 1
wingL1_index = 2
wingR1_index = 3

head_loc = locations[:, HEAD_INDEX, :, :]
thorax_loc = locations[:, THORAX_INDEX, :, :]
wingL1_loc = locations[:, wingL1_index, :, :]
wingR1_loc = locations[:, wingR1_index, :, :]



import seaborn as sns
import matplotlib as mpl
import matplotlib.pyplot as plt

sns.set('notebook', 'ticks', font_scale=1.2)
mpl.rcParams['figure.figsize'] = [15,6]

### Thorax Location

import matplotlib.pyplot as plt

# Assuming thorax_loc is a 3D array with shape (frames, coordinates, flies)

# Define the plot size and axis limits
plot_size = (7, 7)
axis_limits = (0, 1500)

# Define pixel intervals for ticks
pixel_interval = 500  # Change this to your desired interval

# Plot thorax tracks in 2D space for all animals
plt.figure(figsize=plot_size)
plt.plot(thorax_loc[:, 0, 0], thorax_loc[:, 1, 0], 'red', label='fly-1')
plt.plot(thorax_loc[:, 0, 1], thorax_loc[:, 1, 1], 'blue', label='fly-2')
plt.plot(thorax_loc[:, 0, 2], thorax_loc[:, 1, 2], 'yellow', label='fly-2')  # Added fly-2

plt.xlim(axis_limits)
plt.ylim(axis_limits)
plt.xticks([])
plt.yticks([])
plt.xlabel('X Coordinate (Pixels)')
plt.ylabel('Y Coordinate (Pixels)')
plt.xticks(np.arange(0, 1501, pixel_interval))
plt.yticks(np.arange(0, 1501, pixel_interval))
plt.legend()
plt.title('Thorax tracks in 2D space for all flies')
plt.savefig('thorax_tracks_all_flies.png')  # Save the plot
plt.show()

# Define colors for each fly
colors = ['red', 'blue', 'yellow']

# Plot each fly's trajectory separately
for i in range(3):  # Assuming there are 3 flies
    plt.figure(figsize=plot_size)
    plt.plot(thorax_loc[:, 0, i], thorax_loc[:, 1, i], colors[i], label=f'fly-{i+1}')

    plt.xlim(axis_limits)
    plt.ylim(axis_limits)
    plt.xticks([])
    plt.yticks([])
    plt.xlabel('X Coordinate (Pixels)')
    plt.ylabel('Y Coordinate (Pixels)')
    plt.xticks(np.arange(0, 1501, pixel_interval))
    plt.yticks(np.arange(0, 1501, pixel_interval))
    plt.legend()
    plt.title(f'Thorax tracks for fly-{i+1}')
    plt.savefig(f'thorax_tracks_fly_{i+1}.png')  # Save the plot for each fly
    plt.show()

### Dynamic Plotting of Thorax tracks

import numpy as np
import cv2 #OpenCV
from google.colab.patches import cv2_imshow
import os
import h5py


# Assuming thorax_loc is a 3D array with shape (frames, coordinates, flies)

# Define colors for each fly in BGR format
colors = [
    (0, 0, 255),  # Red
    (255, 0, 0),  # Blue
    (0, 255, 255) # Yellow
]

# Define the plot size and axis limits
plot_width, plot_height = 1500, 1500
axis_limits = (0, 1500)

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('thorax_tracks.mp4', fourcc, 30, (plot_width, plot_height))


# Initialize previous positions for drawing lines
prev_positions = [None, None, None]

# Change this directory where you have kept your .h5 file

filename = "19_23k_labels.v001.000_Cropped_19_23k.analysis.h5"

if not os.path.exists(filename):
    print(f"File not found: {filename}")
else:
    with h5py.File(filename, "r") as f:
        dset_names = list(f.keys())
        locations = f["tracks"][:].T
        node_names = [n.decode() for n in f["node_names"][:]]

    print("===filename===")
    print(filename)
    print()

    print("===HDF5 datasets===")
    print(dset_names)
    print()

    print("===locations data shape===")
    print(locations.shape)
    print()

    print("===nodes===")
    for i, name in enumerate(node_names):
        print(f"{i}: {name}")
    print()


    # Define indices for head and thorax
    HEAD_INDEX = 0
    THORAX_INDEX = 1

    head_loc = locations[:, HEAD_INDEX, :, :]
    thorax_loc = locations[:, THORAX_INDEX, :, :]

    num_frames = thorax_loc.shape[0]

    plot_img = np.ones((plot_height, plot_width, 3), dtype=np.uint8) * 255

    # Plot thorax tracks for a limited number of frames
    for frame_idx in range(num_frames):

        # Plot each fly's trajectory
        for i in range(3):  # Assuming there are 3 flies
            x_pos = int(thorax_loc[frame_idx, 0, i])
            y_pos = int(thorax_loc[frame_idx, 1, i])

            # Draw a line from the previous point to the current point
            if prev_positions[i] is not None:
                cv2.line(plot_img, prev_positions[i], (x_pos, y_pos), colors[i], 2)

            # Update the previous position
            prev_positions[i] = (x_pos, y_pos)

        # Draw bold X and Y axes
        cv2.line(plot_img, (50, plot_height - 50), (plot_width - 50, plot_height - 50), (0, 0, 0), 2)  # X-axis
        cv2.line(plot_img, (50, plot_height - 50), (50, 50), (0, 0, 0), 2)  # Y-axis

        # Add axis labels
        cv2.putText(plot_img, 'X Coordinate (Pixels)', (plot_width - 200, plot_height - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
        cv2.putText(plot_img, 'Y Coordinate (Pixels)', (60, 40), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

        # Add tick marks and units
        pixel_interval = 500
        for tick in range(0, 1501, pixel_interval):
            x_tick = 50 + tick
            y_tick = plot_height - 50 - tick
            cv2.line(plot_img, (x_tick, plot_height - 55), (x_tick, plot_height - 45), (0, 0, 0), 1)
            cv2.line(plot_img, (45, y_tick), (55, y_tick), (0, 0, 0), 1)
            cv2.putText(plot_img, f'{tick}', (x_tick - 20, plot_height - 30), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)
            cv2.putText(plot_img, f'{tick}', (20, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

        # Add legend
        legend_x = plot_width - 200
        legend_y_start = 60
        legend_spacing = 20
        cv2.putText(plot_img, 'Legend:', (legend_x, legend_y_start), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
        cv2.putText(plot_img, 'Red: Fly 1', (legend_x, legend_y_start + legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[0], 1, cv2.LINE_AA)
        cv2.putText(plot_img, 'Blue: Fly 2', (legend_x, legend_y_start + 2 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[1], 1, cv2.LINE_AA)
        cv2.putText(plot_img, 'Yellow: Fly 3', (legend_x, legend_y_start + 3 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[2], 1, cv2.LINE_AA)

        # Write the frame to the video file
        video_writer.write(plot_img)

        # Display the plot image
        cv2_imshow(plot_img)

    # Release the video writer and close all windows
    video_writer.release()



### Distance between WingL1 and WingR1

import numpy as np
import matplotlib.pyplot as plt

# Define colors for each fly
colors = ['red', 'blue', 'green']

# Plot the distance between wingL1 and wingR1 for each fly separately
for i in range(3):  # Assuming there are 3 flies
    # Calculate the Euclidean distance between wingL1 and wingR1 for each frame
    distances = np.sqrt((wingL1_loc[:, 0, i] - wingR1_loc[:, 0, i])**2 +
                        (wingL1_loc[:, 1, i] - wingR1_loc[:, 1, i])**2)

    plt.figure()
    plt.plot(distances, colors[i], label=f'Distance fly-{i+1}')
    plt.xlabel('Frame')
    plt.ylabel('Distance (pixels)')
    plt.title(f'Distance between WingL1 and WingR1 for fly-{i+1}')
    plt.xticks(np.arange(0, len(distances), 2000))  # Set X-axis ticks every 2000 frames
    plt.legend()

    # Save the plot before showing it
    plt.savefig(f'Distance_between_WingL1_and_WingR1_fly_{i+1}.png')
    plt.show()

# Plot all flies together (optional)
plt.figure()
for i in range(3):  # Assuming there are 3 flies
    distances = np.sqrt((wingL1_loc[:, 0, i] - wingR1_loc[:, 0, i])**2 +
                        (wingL1_loc[:, 1, i] - wingR1_loc[:, 1, i])**2)
    plt.plot(distances, colors[i], label=f'Distance fly-{i+1}')

plt.xlabel('Frame')
plt.ylabel('Distance (pixels)')
plt.title('Distance between WingL1 and WingR1 for all flies')
plt.xticks(np.arange(0, len(distances), 2000))  # Set X-axis ticks every 2000 frames
plt.legend()

# Save the combined plot before showing it
plt.savefig('Distance_between_WingL1_and_WingR1_all_flies.png')
plt.show()





### Angle between wingL1 and wingR1

import numpy as np
import matplotlib.pyplot as plt

HEAD_INDEX = 0
THORAX_INDEX = 1
wingL1_index = 2
wingR1_index = 3

head_loc = locations[:, HEAD_INDEX, :, :]
thorax_loc = locations[:, THORAX_INDEX, :, :]
wingL1_loc = locations[:, wingL1_index, :, :]
wingR1_loc = locations[:, wingR1_index, :, :]

# Define colors for each fly
colors = ['red', 'blue', 'green']

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    dot_product = np.dot(v1, v2)
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    angle = np.arccos(np.clip(cos_theta, -1.0, 1.0))  # Clip to handle numerical errors
    return np.degrees(angle)

# Plot the angle between wingL1 and wingR1 for each fly separately
for i in range(3):  # Assuming there are 3 flies
    # Calculate the vector from thorax to wingL1 and wingR1
    vector_L1 = wingL1_loc[:, :, i] - thorax_loc[:, :, i]
    vector_R1 = wingR1_loc[:, :, i] - thorax_loc[:, :, i]

    # Calculate the angle between the vectors for each frame
    angles = np.array([calculate_angle(vector_L1[j], vector_R1[j]) for j in range(len(vector_L1))])

    plt.figure()
    plt.plot(angles, colors[i], label=f'Angle fly-{i+1}')
    plt.xlabel('Frame')
    plt.ylabel('Angle (degrees)')
    plt.title(f'Angle between WingL1 and WingR1 for fly-{i+1}')
    plt.xticks(np.arange(0, len(angles), 500))  # Set X-axis ticks every 2000 frames
    plt.legend()
    plt.show()

# Plot all flies together (optional)
plt.figure()
for i in range(3):  # Assuming there are 3 flies
    vector_L1 = wingL1_loc[:, :, i] - thorax_loc[:, :, i]
    vector_R1 = wingR1_loc[:, :, i] - thorax_loc[:, :, i]
    angles = np.array([calculate_angle(vector_L1[j], vector_R1[j]) for j in range(len(vector_L1))])
    plt.plot(angles, colors[i], label=f'Angle fly-{i+1}')

plt.xlabel('Frame')
plt.ylabel('Angle (degrees)')
plt.title('Angle between WingL1 and WingR1 for all flies')
plt.xticks(np.arange(0, len(angles), 500))  # Set X-axis ticks every 2000 frames
plt.legend()
plt.show()

### Dynamic Plotting of angle between wingL1 and WingR1

import numpy as np
import cv2

HEAD_INDEX = 0
THORAX_INDEX = 1
wingL1_index = 2
wingR1_index = 3

head_loc = locations[:, HEAD_INDEX, :, :]
thorax_loc = locations[:, THORAX_INDEX, :, :]
wingL1_loc = locations[:, wingL1_index, :, :]
wingR1_loc = locations[:, wingR1_index, :, :]

# Define colors for each fly in BGR format
colors = [
    (255, 0, 0),   # Blue for the third animal
    (0, 165, 255), # Yellow for the first animal
    (0, 255, 255)  # Orange for the second animal
]

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    dot_product = np.dot(v1, v2)
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    angle = np.arccos(np.clip(cos_theta, -1.0, 1.0))  # Clip to handle numerical errors
    return np.degrees(angle)

# Create a window to display the plot
cv2.namedWindow('Angle Plot', cv2.WINDOW_NORMAL)

fps = 30
frames_per_minute = fps * 60
wait_time = int(1000 / fps)

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('angle_plot.mp4', fourcc, fps, (800, 400))

# Calculate angles for each fly
angles_all = []
for i in range(3):  # Assuming there are 3 flies
    vector_L1 = wingL1_loc[:, :, i] - thorax_loc[:, :, i]
    vector_R1 = wingR1_loc[:, :, i] - thorax_loc[:, :, i]
    angles = np.array([calculate_angle(vector_L1[j], vector_R1[j]) for j in range(len(vector_L1))])
    angles_all.append(angles)

# Create a blank image for plotting with a white background
plot_img = np.ones((400, 800, 3), dtype=np.uint8) * 255

# Define plot area
x_start, x_end = 50, 750
y_start, y_end = 350, 50  # Inverted Y-axis for plotting

# Plot angles at 30 fps
for frame_idx in range(5000):  # Plotting all 4001 frames
    # Plot angles for each fly
    for i, angles in enumerate(angles_all):
        if frame_idx > 0 and frame_idx < len(angles):
            # Scale the angle to fit within the plot area (0 to 90 degrees)
            x1 = int(x_start + (frame_idx-1) * (x_end - x_start) / 4000)
            x2 = int(x_start + frame_idx * (x_end - x_start) / 4000)
            y1 = int(y_start - (angles[frame_idx-1] / 90.0) * (y_start - y_end))
            y2 = int(y_start - (angles[frame_idx] / 90.0) * (y_start - y_end))
            cv2.line(plot_img, (x1, y1), (x2, y2), colors[i], 1)

    # Draw X and Y axes
    cv2.line(plot_img, (x_start, y_start), (x_end, y_start), (0, 0, 0), 2)  # X-axis
    cv2.line(plot_img, (x_start, y_start), (x_start, y_end), (0, 0, 0), 2)  # Y-axis

    # Add labels to the axes
    cv2.putText(plot_img, 'Time (min)', (x_end - 100, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Angle', (x_start - 40, y_end - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

    # Add tick marks and units for time in 30-second intervals
    for tick in range(0, 4001, 900):  # X-axis ticks for every 30 seconds (900 frames)
        x_tick = int(x_start + tick * (x_end - x_start) / 4000)
        minutes = tick / frames_per_minute
        cv2.line(plot_img, (x_tick, y_start), (x_tick, y_start + 5), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{minutes:.2f}', (x_tick - 10, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    for tick in range(0, 91, 15):  # Y-axis ticks for every 15 degrees
        y_tick = int(y_start - (tick / 90.0) * (y_start - y_end))
        cv2.line(plot_img, (x_start - 5, y_tick), (x_start, y_tick), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick}', (x_start - 30, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    # Write the frame to the video file
    video_writer.write(plot_img)

    # Display the plot image
    cv2.imshow('Angle Plot', plot_img)

    # Wait for a key press and check if 'q' is pressed to quit
    if cv2.waitKey(wait_time) & 0xFF == ord('q'):
        break

# Release the video writer and close all windows
video_writer.release()
cv2.destroyAllWindows()





### Relative angle between animals

import numpy as np
import matplotlib.pyplot as plt

# Assuming the structure of locations is [frames, nodes, coordinates, animals]
# For example, locations[frame, node, coordinate, animal]

# Define indices for head and thorax
HEAD_INDEX = 0
THORAX_INDEX = 1

# Define colors for each comparison
colors = ['red', 'blue', 'green']

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    if norm_v1 == 0 or norm_v2 == 0:
        return np.nan  # Return NaN if either vector is zero
    dot_product = np.dot(v1, v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clip to handle numerical errors
    angle = np.arccos(cos_theta)
    return np.degrees(angle)

# Define frame range here
start_frame = 0  # Change this to your desired start frame
end_frame = 4001  # Change this to your desired end frame

# Convert frames to time in minutes
frame_rate = 30  # frames per second
time_in_minutes = np.arange(start_frame, end_frame) / frame_rate / 60

# Plot individual comparisons
for i in range(3):  # Compare animal 0 with 1 and 2, and animal 1 with 2
    plt.figure()
    if i < 2:
        # Compare animal 0 with animal 1 and 2
        vector_animal1 = locations[start_frame:end_frame, THORAX_INDEX, :, 0] - locations[start_frame:end_frame, HEAD_INDEX, :, 0]
        vector_animal2 = locations[start_frame:end_frame, THORAX_INDEX, :, i+1] - locations[start_frame:end_frame, HEAD_INDEX, :, i+1]
        label = f'Animal 1 vs Animal {i+2}'
    else:
        # Compare animal 1 with animal 2
        vector_animal1 = locations[start_frame:end_frame, THORAX_INDEX, :, 1] - locations[start_frame:end_frame, HEAD_INDEX, :, 1]
        vector_animal2 = locations[start_frame:end_frame, THORAX_INDEX, :, 2] - locations[start_frame:end_frame, HEAD_INDEX, :, 2]
        label = 'Fly 2 vs Fly 3'

    # Calculate the angle between the vectors for each frame
    angles = np.array([calculate_angle(vector_animal1[j], vector_animal2[j]) for j in range(len(vector_animal1))])

    # Calculate and print the average angle
    average_angle = np.nanmean(angles)
    print(f'Average relative angle for {label}: {average_angle:.2f} degrees')

    plt.plot(time_in_minutes, angles, colors[i], label=label)
    plt.xlabel('Time (minutes)')
    plt.ylabel('Relative Angle (degrees)')
    plt.title(f'Relative Angle for {label}')
    plt.xticks(np.arange(time_in_minutes[0], time_in_minutes[-1], 0.5))  # Set X-axis ticks every 1 minute
    plt.legend()
    plt.show()

# Plot all comparisons together
plt.figure()
for i in range(3):
    if i < 2:
        vector_animal1 = locations[start_frame:end_frame, THORAX_INDEX, :, 0] - locations[start_frame:end_frame, HEAD_INDEX, :, 0]
        vector_animal2 = locations[start_frame:end_frame, THORAX_INDEX, :, i+1] - locations[start_frame:end_frame, HEAD_INDEX, :, i+1]
        label = f'Animal 1 vs Animal {i+2}'
    else:
        vector_animal1 = locations[start_frame:end_frame, THORAX_INDEX, :, 1] - locations[start_frame:end_frame, HEAD_INDEX, :, 1]
        vector_animal2 = locations[start_frame:end_frame, THORAX_INDEX, :, 2] - locations[start_frame:end_frame, HEAD_INDEX, :, 2]
        label = 'Fly 2 vs Fly 3'

    angles = np.array([calculate_angle(vector_animal1[j], vector_animal2[j]) for j in range(len(vector_animal1))])
    plt.plot(time_in_minutes, angles, colors[i], label=label)

plt.xlabel('Time (minutes)')
plt.ylabel('Relative Angle (degrees)')
plt.title('Relative Angle between Flies')
plt.xticks(np.arange(time_in_minutes[0], time_in_minutes[-1], 0.5))  # Set X-axis ticks every 1 minute
plt.legend()
plt.show()

### Dynamic ploting of relative angle between flies

import numpy as np
import cv2

# Assuming the structure of locations is [frames, nodes, coordinates, animals]
# For example, locations[frame, node, coordinate, animal]

# Define indices for head and thorax
HEAD_INDEX = 0
THORAX_INDEX = 1

# Define colors for each comparison in BGR format
colors = [
    (0, 0, 255),  # Red
    (255, 0, 0),  # Blue
    (0, 255, 0)   # Green
]

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    if norm_v1 == 0 or norm_v2 == 0:
        return np.nan  # Return NaN if either vector is zero
    dot_product = np.dot(v1, v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clip to handle numerical errors
    angle = np.arccos(cos_theta)
    return np.degrees(angle)

# Define frame range here
start_frame = 0
end_frame = 4001

# Convert frames to time in minutes
frame_rate = 30  # frames per second
frames_per_minute = frame_rate * 60
time_in_minutes = np.arange(start_frame, end_frame) / frame_rate / 60

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('relative_angle_plot.mp4', fourcc, frame_rate, (800, 400))

# Create a blank image for plotting with a white background
plot_img = np.ones((400, 800, 3), dtype=np.uint8) * 255

# Define plot area
x_start, x_end = 50, 750
y_start, y_end = 350, 50  # Inverted Y-axis for plotting

# Initialize previous positions for drawing lines
prev_positions = [None, None, None]

# Calculate angles and plot
for frame_idx in range(start_frame, end_frame):
    # Plot individual comparisons
    for i in range(3):  # Compare animal 0 with 1 and 2, and animal 1 with 2
        if i < 2:
            vector_animal1 = locations[frame_idx, THORAX_INDEX, :, 0] - locations[frame_idx, HEAD_INDEX, :, 0]
            vector_animal2 = locations[frame_idx, THORAX_INDEX, :, i+1] - locations[frame_idx, HEAD_INDEX, :, i+1]
        else:
            vector_animal1 = locations[frame_idx, THORAX_INDEX, :, 1] - locations[frame_idx, HEAD_INDEX, :, 1]
            vector_animal2 = locations[frame_idx, THORAX_INDEX, :, 2] - locations[frame_idx, HEAD_INDEX, :, 2]

        # Calculate the angle between the vectors for the current frame
        angle = calculate_angle(vector_animal1, vector_animal2)

        # Only plot if the angle is a valid number
        if not np.isnan(angle):
            # Scale the angle to fit within the plot area (0 to 180 degrees)
            x_pos = int(x_start + frame_idx * (x_end - x_start) / (end_frame - start_frame))
            y_pos = int(y_start - (angle / 180.0) * (y_start - y_end))

            # Draw a line from the previous point to the current point
            if prev_positions[i] is not None:
                cv2.line(plot_img, prev_positions[i], (x_pos, y_pos), colors[i], 1)

            # Update the previous position
            prev_positions[i] = (x_pos, y_pos)
        else:
            # Reset previous position if angle is NaN
            prev_positions[i] = None

    # Draw X and Y axes
    cv2.line(plot_img, (x_start, y_start), (x_end, y_start), (0, 0, 0), 2)  # X-axis
    cv2.line(plot_img, (x_start, y_start), (x_start, y_end), (0, 0, 0), 2)  # Y-axis

    # Add labels to the axes
    cv2.putText(plot_img, 'Time (min)', (x_end - 100, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Angle', (x_start - 40, y_end - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

    # Add tick marks and units for time in 30-second intervals
    for tick in range(0, end_frame, 900):  # X-axis ticks for every 30 seconds (900 frames)
        x_tick = int(x_start + tick * (x_end - x_start) / (end_frame - start_frame))
        minutes = tick / frames_per_minute
        cv2.line(plot_img, (x_tick, y_start), (x_tick, y_start + 5), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{minutes:.2f}', (x_tick - 10, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    for tick in range(0, 181, 30):  # Y-axis ticks for every 30 degrees
        y_tick = int(y_start - (tick / 180.0) * (y_start - y_end))
        cv2.line(plot_img, (x_start - 5, y_tick), (x_start, y_tick), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick}', (x_start - 30, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    # Add legend to the top right corner
    legend_x = x_end - 200  # Adjusted X position for better visibility
    legend_y_start = 5
    legend_spacing = 20
    cv2.putText(plot_img, 'Animal 1 vs Animal 2', (legend_x, legend_y_start + legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[0], 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Animal 1 vs Animal 3', (legend_x, legend_y_start + 2 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[1], 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Animal 2 vs Animal 3', (legend_x, legend_y_start + 3 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[2], 1, cv2.LINE_AA)

    # Write the frame to the video file
    video_writer.write(plot_img)

    # Display the plot image
    cv2.imshow('Angle Plot', plot_img)

    # Wait for a key press and check if 'q' is pressed to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video writer and close all windows
video_writer.release()
cv2.destroyAllWindows()





import numpy as np
import cv2

# Assuming the structure of locations is [frames, nodes, coordinates, animals]
# For example, locations[frame, node, coordinate, animal]

# Define indices for head and thorax
HEAD_INDEX = 0
THORAX_INDEX = 1

# Define colors for each comparison in BGR format
colors = [
    (0, 0, 255),  # Red
    (255, 0, 0),  # Blue
    (0, 255, 0)   # Green
]

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    if norm_v1 == 0 or norm_v2 == 0:
        return np.nan  # Return NaN if either vector is zero
    dot_product = np.dot(v1, v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clip to handle numerical errors
    angle = np.arccos(cos_theta)
    return np.degrees(angle)

# Specify which two animals to compare
animal1 = 0  # Change this to the index of the first animal
animal3 = 2  # Change this to the index of the second animal

# Define frame range here
start_frame = 0
end_frame = 4001

# Convert frames to time in minutes
frame_rate = 30  # frames per second
frames_per_minute = frame_rate * 60
time_in_minutes = np.arange(start_frame, end_frame) / frame_rate / 60

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('relative_angle_plot_1_3.mp4', fourcc, frame_rate, (800, 400))

# Create a blank image for plotting with a white background
plot_img = np.ones((400, 800, 3), dtype=np.uint8) * 255

# Define plot area
x_start, x_end = 50, 750
y_start, y_end = 350, 50  # Inverted Y-axis for plotting

# Initialize previous position for drawing lines
prev_position = None

# Calculate angles and plot
for frame_idx in range(start_frame, end_frame):
    # Calculate vectors for the specified animals
    vector_animal1 = locations[frame_idx, THORAX_INDEX, :, animal1] - locations[frame_idx, HEAD_INDEX, :, animal1]
    vector_animal3 = locations[frame_idx, THORAX_INDEX, :, animal3] - locations[frame_idx, HEAD_INDEX, :, animal3]

    # Calculate the angle between the vectors for the current frame
    angle = calculate_angle(vector_animal1, vector_animal3)

    # Only plot if the angle is a valid number
    if not np.isnan(angle):
        # Scale the angle to fit within the plot area (0 to 180 degrees)
        x_pos = int(x_start + frame_idx * (x_end - x_start) / (end_frame - start_frame))
        y_pos = int(y_start - (angle / 180.0) * (y_start - y_end))

        # Draw a line from the previous point to the current point
        if prev_position is not None:
            cv2.line(plot_img, prev_position, (x_pos, y_pos), colors[0], 1)

        # Update the previous position
        prev_position = (x_pos, y_pos)
    else:
        # Reset previous position if angle is NaN
        prev_position = None

    # Draw X and Y axes
    cv2.line(plot_img, (x_start, y_start), (x_end, y_start), (0, 0, 0), 2)  # X-axis
    cv2.line(plot_img, (x_start, y_start), (x_start, y_end), (0, 0, 0), 2)  # Y-axis

    # Add labels to the axes
    cv2.putText(plot_img, 'Time (min)', (x_end - 100, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Angle', (x_start - 40, y_end - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

    # Add tick marks and units for time in 30-second intervals
    for tick in range(0, end_frame, 900):  # X-axis ticks for every 30 seconds (900 frames)
        x_tick = int(x_start + tick * (x_end - x_start) / (end_frame - start_frame))
        minutes = tick / frames_per_minute
        cv2.line(plot_img, (x_tick, y_start), (x_tick, y_start + 5), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{minutes:.2f}', (x_tick - 10, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    for tick in range(0, 181, 30):  # Y-axis ticks for every 30 degrees
        y_tick = int(y_start - (tick / 180.0) * (y_start - y_end))
        cv2.line(plot_img, (x_start - 5, y_tick), (x_start, y_tick), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick}', (x_start - 30, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    # Add legend to the top right corner
    legend_x = x_end - 200  # Adjusted X position for better visibility
    legend_y_start = 5
    legend_spacing = 20
    cv2.putText(plot_img, f'Animal {animal1 + 1} vs Animal {animal3 + 1}', (legend_x, legend_y_start + legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[0], 1, cv2.LINE_AA)

    # Write the frame to the video file
    video_writer.write(plot_img)

    # Display the plot image
    cv2.imshow('Angle Plot', plot_img)

    # Wait for a key press and check if 'q' is pressed to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video writer and close all windows
video_writer.release()
cv2.destroyAllWindows()











### WingL1 angle with body
To create a plot that calculates a straight line based on the positions of the head and thorax and then plots the angle it forms with WingL1 for each animal, you can follow these steps:

**Calculate the Vector**: Compute the vector from the head to the thorax for each frame and each animal.

**Calculate the Angle**: Compute the angle between this vector and the WingL1 vector for each frame and each animal.

**Plot the Angles**: Use OpenCV to plot these angles over time.


import numpy as np
import cv2

# Assuming locations is a 4D array with shape (frames, nodes, coordinates, animals)
# For example, locations[frame, node, coordinate, animal]

# Define indices for head, thorax, and WingL1
HEAD_INDEX = 0
THORAX_INDEX = 1
wingL1_index = 2

# Define colors for each animal in BGR format
colors = [
    (0, 0, 255),  # Red for animal 1
    (255, 0, 0),  # Blue for animal 2
    (0, 255, 0)   # Green for animal 3
]

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    if norm_v1 == 0 or norm_v2 == 0:
        return np.nan  # Return NaN if either vector is zero
    dot_product = np.dot(v1, v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clip to handle numerical errors
    angle = np.arccos(cos_theta)
    return np.degrees(angle)

# Define frame range here
start_frame = 0
end_frame = 4001

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('angle_with_wingL1.mp4', fourcc, 30, (800, 400))

# Create a blank image for plotting with a white background
plot_img = np.ones((400, 800, 3), dtype=np.uint8) * 255

# Define plot area
x_start, x_end = 50, 750
y_start, y_end = 350, 50  # Inverted Y-axis for plotting

# Initialize previous positions for drawing lines
prev_positions = [None, None, None]

# Calculate angles and plot
for frame_idx in range(start_frame, end_frame):
    # Plot individual comparisons
    for i in range(3):  # Assuming there are 3 animals
        # Calculate vectors
        vector_head_thorax = locations[frame_idx, THORAX_INDEX, :, i] - locations[frame_idx, HEAD_INDEX, :, i]
        vector_wingL1 = locations[frame_idx, wingL1_index, :, i] - locations[frame_idx, HEAD_INDEX, :, i]

        # Calculate the angle between the head-thorax line and WingL1
        angle = calculate_angle(vector_head_thorax, vector_wingL1)

        # Only plot if the angle is a valid number
        if not np.isnan(angle):
            # Scale the angle to fit within the plot area (0 to 90 degrees)
            x_pos = int(x_start + frame_idx * (x_end - x_start) / (end_frame - start_frame))
            y_pos = int(y_start - (angle / 90) * (y_start - y_end))

            # Draw a line from the previous point to the current point
            if prev_positions[i] is not None:
                cv2.line(plot_img, prev_positions[i], (x_pos, y_pos), colors[i], 1)

            # Update the previous position
            prev_positions[i] = (x_pos, y_pos)
        else:
            # Reset previous position if angle is NaN
            prev_positions[i] = None

    # Draw X and Y axes
    cv2.line(plot_img, (x_start, y_start), (x_end, y_start), (0, 0, 0), 2)  # X-axis
    cv2.line(plot_img, (x_start, y_start), (x_start, y_end), (0, 0, 0), 2)  # Y-axis

    # Add labels to the axes
    cv2.putText(plot_img, 'Frame', (x_end - 50, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Angle (degrees)', (x_start - 80, y_end - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

    # Add tick marks and units
    for tick in range(0, end_frame, 900):  # X-axis ticks for every 30 seconds (900 frames)
        x_tick = int(x_start + tick * (x_end - x_start) / (end_frame - start_frame))
        cv2.line(plot_img, (x_tick, y_start), (x_tick, y_start + 5), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick // 30}', (x_tick - 10, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    for tick in range(0, 181, 30):  # Y-axis ticks for every 30 degrees
        y_tick = int(y_start - (tick / 90) * (y_start - y_end))
        cv2.line(plot_img, (x_start - 5, y_tick), (x_start, y_tick), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick}', (x_start - 30, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    # Add legend
    legend_x = x_end - 200
    legend_y_start = 10
    legend_spacing = 20
    cv2.putText(plot_img, 'Animal 1', (legend_x, legend_y_start + legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[0], 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Animal 2', (legend_x, legend_y_start + 2 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[1], 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Animal 3', (legend_x, legend_y_start + 3 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[2], 1, cv2.LINE_AA)

    # Write the frame to the video file
    video_writer.write(plot_img)

    # Display the plot image
    cv2.imshow('Angle with WingL1', plot_img)

    # Wait for a key press and check if 'q' is pressed to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video writer and close all windows
video_writer.release()
cv2.destroyAllWindows()



### WingR1 angle with body


import numpy as np
import cv2

# Assuming locations is a 4D array with shape (frames, nodes, coordinates, animals)
# For example, locations[frame, node, coordinate, animal]

# Define indices for head, thorax, and WingR1
HEAD_INDEX = 0
THORAX_INDEX = 1
wingR1_index = 3  # Update this index to match the correct index for wingR1

# Define colors for each animal in BGR format
colors = [
    (0, 0, 255),  # Red for animal 1
    (255, 0, 0),  # Blue for animal 2
    (0, 255, 0)   # Green for animal 3
]

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    if norm_v1 == 0 or norm_v2 == 0:
        return np.nan  # Return NaN if either vector is zero
    dot_product = np.dot(v1, v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clip to handle numerical errors
    angle = np.arccos(cos_theta)
    return np.degrees(angle)

# Define frame range here
start_frame = 0
end_frame = 4001

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('angle_with_wingR1.mp4', fourcc, 30, (800, 400))

# Create a blank image for plotting with a white background
plot_img = np.ones((400, 800, 3), dtype=np.uint8) * 255

# Define plot area
x_start, x_end = 50, 750
y_start, y_end = 350, 50  # Inverted Y-axis for plotting

# Initialize previous positions for drawing lines
prev_positions = [None, None, None]

# Calculate angles and plot
for frame_idx in range(start_frame, end_frame):
    # Plot individual comparisons
    for i in range(3):  # Assuming there are 3 animals
        # Calculate vectors
        vector_head_thorax = locations[frame_idx, THORAX_INDEX, :, i] - locations[frame_idx, HEAD_INDEX, :, i]
        vector_wingR1 = locations[frame_idx, wingR1_index, :, i] - locations[frame_idx, HEAD_INDEX, :, i]

        # Calculate the angle between the head-thorax line and WingR1
        angle = calculate_angle(vector_head_thorax, vector_wingR1)

        # Only plot if the angle is a valid number
        if not np.isnan(angle):
            # Scale the angle to fit within the plot area (0 to 90 degrees)
            x_pos = int(x_start + frame_idx * (x_end - x_start) / (end_frame - start_frame))
            y_pos = int(y_start - (angle / 90) * (y_start - y_end))

            # Draw a line from the previous point to the current point
            if prev_positions[i] is not None:
                cv2.line(plot_img, prev_positions[i], (x_pos, y_pos), colors[i], 1)

            # Update the previous position
            prev_positions[i] = (x_pos, y_pos)
        else:
            # Reset previous position if angle is NaN
            prev_positions[i] = None

    # Draw X and Y axes
    cv2.line(plot_img, (x_start, y_start), (x_end, y_start), (0, 0, 0), 2)  # X-axis
    cv2.line(plot_img, (x_start, y_start), (x_start, y_end), (0, 0, 0), 2)  # Y-axis

    # Add labels to the axes
    cv2.putText(plot_img, 'Frame', (x_end - 50, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Angle (degrees)', (x_start - 80, y_end - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

    # Add tick marks and units
    for tick in range(0, end_frame, 900):  # X-axis ticks for every 30 seconds (900 frames)
        x_tick = int(x_start + tick * (x_end - x_start) / (end_frame - start_frame))
        cv2.line(plot_img, (x_tick, y_start), (x_tick, y_start + 5), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick // 30}', (x_tick - 10, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    for tick in range(0, 181, 30):  # Y-axis ticks for every 30 degrees
        y_tick = int(y_start - (tick / 90) * (y_start - y_end))
        cv2.line(plot_img, (x_start - 5, y_tick), (x_start, y_tick), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick}', (x_start - 30, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    # Add legend
    legend_x = x_end - 200
    legend_y_start = 10
    legend_spacing = 10
    cv2.putText(plot_img, 'Animal 1', (legend_x, legend_y_start + legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[0], 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Animal 2', (legend_x, legend_y_start + 2 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[1], 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Animal 3', (legend_x, legend_y_start + 3 * legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[2], 1, cv2.LINE_AA)

    # Write the frame to the video file
    video_writer.write(plot_img)

    # Display the plot image
    cv2.imshow('Angle with WingR1', plot_img)

    # Wait for a key press and check if 'q' is pressed to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video writer and close all windows
video_writer.release()
cv2.destroyAllWindows()



### To Plot wingR1 angle to body axis only for one animal

import numpy as np
import cv2

# Assuming locations is a 4D array with shape (frames, nodes, coordinates, animals)
# For example, locations[frame, node, coordinate, animal]

# Define indices for head, thorax, and WingR1
HEAD_INDEX = 0
THORAX_INDEX = 1
wingR1_index = 3  # Update this index to match the correct index for wingR1

# Define colors for each animal in BGR format
colors = [
    (0, 0, 255),  # Red for animal 1
    (255, 0, 0),  # Blue for animal 2
    (0, 255, 0)   # Green for animal 3
]

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    if norm_v1 == 0 or norm_v2 == 0:
        return np.nan  # Return NaN if either vector is zero
    dot_product = np.dot(v1, v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clip to handle numerical errors
    angle = np.arccos(cos_theta)
    return np.degrees(angle)

# Define frame range here
start_frame = 0
end_frame = 4001

# Specify the animal index to plot
animal_index = 2  # Change this index to plot a different animal

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('Animal_3_WingR1_angle_with_body.mp4', fourcc, 30, (800, 400))

# Create a blank image for plotting with a white background
plot_img = np.ones((400, 800, 3), dtype=np.uint8) * 255

# Define plot area
x_start, x_end = 50, 750
y_start, y_end = 350, 50  # Inverted Y-axis for plotting

# Initialize previous position for drawing lines
prev_position = None

# Calculate angles and plot
for frame_idx in range(start_frame, end_frame):
    # Calculate vectors
    vector_head_thorax = locations[frame_idx, THORAX_INDEX, :, animal_index] - locations[frame_idx, HEAD_INDEX, :, animal_index]
    vector_wingR1 = locations[frame_idx, wingR1_index, :, animal_index] - locations[frame_idx, HEAD_INDEX, :, animal_index]

    # Calculate the angle between the head-thorax line and WingR1
    angle = calculate_angle(vector_head_thorax, vector_wingR1)

    # Only plot if the angle is a valid number
    if not np.isnan(angle):
        # Scale the angle to fit within the plot area (0 to 90 degrees)
        x_pos = int(x_start + frame_idx * (x_end - x_start) / (end_frame - start_frame))
        y_pos = int(y_start - (angle / 90) * (y_start - y_end))

        # Draw a line from the previous point to the current point
        if prev_position is not None:
            cv2.line(plot_img, prev_position, (x_pos, y_pos), colors[animal_index], 1)

        # Update the previous position
        prev_position = (x_pos, y_pos)
    else:
        # Reset previous position if angle is NaN
        prev_position = None

    # Draw X and Y axes
    cv2.line(plot_img, (x_start, y_start), (x_end, y_start), (0, 0, 0), 2)  # X-axis
    cv2.line(plot_img, (x_start, y_start), (x_start, y_end), (0, 0, 0), 2)  # Y-axis

    # Add labels to the axes
    cv2.putText(plot_img, 'Frame', (x_end - 50, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Angle (degrees)', (x_start - 80, y_end - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

    # Add tick marks and units
    for tick in range(0, end_frame, 900):  # X-axis ticks for every 30 seconds (900 frames)
        x_tick = int(x_start + tick * (x_end - x_start) / (end_frame - start_frame))
        cv2.line(plot_img, (x_tick, y_start), (x_tick, y_start + 5), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick // 30}', (x_tick - 10, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    for tick in range(0, 91, 30):  # Y-axis ticks for every 30 degrees
        y_tick = int(y_start - (tick / 90) * (y_start - y_end))
        cv2.line(plot_img, (x_start - 5, y_tick), (x_start, y_tick), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick}', (x_start - 30, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    # Add legend with animal number
    legend_x = x_end - 200
    legend_y_start = 10
    legend_spacing = 20
    cv2.putText(plot_img, f'Animal {animal_index + 1}', (legend_x, legend_y_start + legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[animal_index], 1, cv2.LINE_AA)

    # Write the frame to the video file
    video_writer.write(plot_img)

    # Display the plot image
    cv2.imshow('Animal_3_WingR1_angle_with_body', plot_img)

    # Wait for a key press and check if 'q' is pressed to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video writer and close all windows
video_writer.release()
cv2.destroyAllWindows()



### To Plot wingL1 angle to body axis only for one animal

import numpy as np
import cv2

# Assuming locations is a 4D array with shape (frames, nodes, coordinates, animals)
# For example, locations[frame, node, coordinate, animal]

# Define indices for head, thorax, and wingL1
HEAD_INDEX = 0
THORAX_INDEX = 1
wingL1_index = 2  # Update this index to match the correct index for wingL1

# Define colors for each animal in BGR format
colors = [
    (0, 0, 255),  # Red for animal 1
    (255, 0, 0),  # Blue for animal 2
    (0, 255, 0)   # Green for animal 3
]

# Function to calculate angle between two vectors
def calculate_angle(v1, v2):
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    if norm_v1 == 0 or norm_v2 == 0:
        return np.nan  # Return NaN if either vector is zero
    dot_product = np.dot(v1, v2)
    cos_theta = dot_product / (norm_v1 * norm_v2)
    cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clip to handle numerical errors
    angle = np.arccos(cos_theta)
    return np.degrees(angle)

# Define frame range here
start_frame = 0
end_frame = 4001

# Specify the animal index to plot
animal_index = 0  # Change this index to plot a different animal

# Setup video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec
video_writer = cv2.VideoWriter('Animal_1_WingL1_angle_with_body.mp4', fourcc, 30, (800, 400))

# Create a blank image for plotting with a white background
plot_img = np.ones((400, 800, 3), dtype=np.uint8) * 255

# Define plot area
x_start, x_end = 50, 750
y_start, y_end = 350, 50  # Inverted Y-axis for plotting

# Initialize previous position for drawing lines
prev_position = None

# Calculate angles and plot
for frame_idx in range(start_frame, end_frame):
    # Calculate vectors
    vector_head_thorax = locations[frame_idx, THORAX_INDEX, :, animal_index] - locations[frame_idx, HEAD_INDEX, :, animal_index]
    vector_wingL1 = locations[frame_idx, wingL1_index, :, animal_index] - locations[frame_idx, HEAD_INDEX, :, animal_index]

    # Calculate the angle between the head-thorax line and WingL1
    angle = calculate_angle(vector_head_thorax, vector_wingL1)

    # Only plot if the angle is a valid number
    if not np.isnan(angle):
        # Scale the angle to fit within the plot area (0 to 90 degrees)
        x_pos = int(x_start + frame_idx * (x_end - x_start) / (end_frame - start_frame))
        y_pos = int(y_start - (angle / 90) * (y_start - y_end))

        # Draw a line from the previous point to the current point
        if prev_position is not None:
            cv2.line(plot_img, prev_position, (x_pos, y_pos), colors[animal_index], 1)

        # Update the previous position
        prev_position = (x_pos, y_pos)
    else:
        # Reset previous position if angle is NaN
        prev_position = None

    # Draw X and Y axes
    cv2.line(plot_img, (x_start, y_start), (x_end, y_start), (0, 0, 0), 2)  # X-axis
    cv2.line(plot_img, (x_start, y_start), (x_start, y_end), (0, 0, 0), 2)  # Y-axis

    # Add labels to the axes
    cv2.putText(plot_img, 'Frame', (x_end - 50, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)
    cv2.putText(plot_img, 'Angle (degrees)', (x_start - 80, y_end - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1, cv2.LINE_AA)

    # Add tick marks and units
    for tick in range(0, end_frame, 900):  # X-axis ticks for every 30 seconds (900 frames)
        x_tick = int(x_start + tick * (x_end - x_start) / (end_frame - start_frame))
        cv2.line(plot_img, (x_tick, y_start), (x_tick, y_start + 5), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick // 30}', (x_tick - 10, y_start + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    for tick in range(0, 91, 30):  # Y-axis ticks for every 30 degrees
        y_tick = int(y_start - (tick / 90) * (y_start - y_end))
        cv2.line(plot_img, (x_start - 5, y_tick), (x_start, y_tick), (0, 0, 0), 1)
        cv2.putText(plot_img, f'{tick}', (x_start - 30, y_tick + 5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 0), 1, cv2.LINE_AA)

    # Add legend with animal number
    legend_x = x_end - 200
    legend_y_start = 10
    legend_spacing = 20
    cv2.putText(plot_img, f'Animal {animal_index + 1}', (legend_x, legend_y_start + legend_spacing), cv2.FONT_HERSHEY_SIMPLEX, 0.5, colors[animal_index], 1, cv2.LINE_AA)

    # Write the frame to the video file
    video_writer.write(plot_img)

    # Display the plot image
    cv2.imshow('Animal_1_WingL1_angle_with_body', plot_img)

    # Wait for a key press and check if 'q' is pressed to quit
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video writer and close all windows
video_writer.release()
cv2.destroyAllWindows()











































